<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Gemini Secure Messenger</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    body { font-family: 'Inter', sans-serif; }
    .custom-scrollbar::-webkit-scrollbar { width: 6px; }
    .custom-scrollbar::-webkit-scrollbar-track { background: #1e293b; }
    .custom-scrollbar::-webkit-scrollbar-thumb { background: #475569; border-radius: 3px; }
    .custom-scrollbar::-webkit-scrollbar-thumb:hover { background: #64748b; }
  </style>
<script type="importmap">
{
  "imports": {
    "@google/genai": "https://aistudiocdn.com/@google/genai@^1.27.0",
    "react-dom/client": "https://aistudiocdn.com/react-dom@18.2.0/client.js",
    "react-dom": "https://aistudiocdn.com/react-dom@18.2.0",
    "react": "https://aistudiocdn.com/react@18.2.0"
  }
}
</script>
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel" data-presets="react,typescript">
    import React, { useState, useEffect, useRef, useCallback } from 'react';
    import ReactDOM from 'react-dom/client';
    import { GoogleGenAI } from '@google/genai';

    // --- CONSOLIDATED APPLICATION CODE ---
    // All .ts and .tsx files have been inlined here to create a single, deployable file.
    
    // --- FROM types.ts ---
    const MessageStatus = {
      SENT: 'sent',
      DELIVERED: 'delivered',
      READ: 'read',
      SENDING: 'sending',
      ERROR: 'error',
    };
    const AIFeature = {
      SMART_REPLY: 'Smarte Antworten',
      REWRITE_FORMAL: 'Formeller umschreiben',
      REWRITE_CASUAL: 'Legerer umschreiben',
    };

    // --- FROM services/cryptoService.ts ---
    function arrayBufferToBase64(buffer) {
        let binary = '';
        const bytes = new Uint8Array(buffer);
        for (let i = 0; i < bytes.byteLength; i++) {
            binary += String.fromCharCode(bytes[i]);
        }
        return window.btoa(binary);
    }
    function base64ToArrayBuffer(base64) {
        const binary_string = window.atob(base64);
        const len = binary_string.length;
        const bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            bytes[i] = binary_string.charCodeAt(i);
        }
        return bytes.buffer;
    }
    async function importPrivateKey(jwk) {
        return await crypto.subtle.importKey('jwk', jwk, { name: 'ECDH', namedCurve: 'P-256' }, true, ['deriveKey']);
    }
    async function importPublicKey(jwk) {
        return await crypto.subtle.importKey('jwk', jwk, { name: 'ECDH', namedCurve: 'P-256' }, true, []);
    }
    async function deriveSharedKey(privateKeyJwk, publicKeyJwk) {
        const privateKey = await importPrivateKey(privateKeyJwk);
        const publicKey = await importPublicKey(publicKeyJwk);
        return await crypto.subtle.deriveKey({ name: 'ECDH', public: publicKey }, privateKey, { name: 'AES-GCM', length: 256 }, true, ['encrypt', 'decrypt']);
    }
    async function encryptMessage(text, key) {
        const encodedText = new TextEncoder().encode(text);
        const iv = crypto.getRandomValues(new Uint8Array(12));
        const ciphertext = await crypto.subtle.encrypt({ name: 'AES-GCM', iv }, key, encodedText);
        const combined = new Uint8Array(iv.length + ciphertext.byteLength);
        combined.set(iv, 0);
        combined.set(new Uint8Array(ciphertext), iv.length);
        return arrayBufferToBase64(combined.buffer);
    }
    async function decryptMessage(encryptedBase64, key) {
        const combined = base64ToArrayBuffer(encryptedBase64);
        const iv = combined.slice(0, 12);
        const ciphertext = combined.slice(12);
        const decrypted = await crypto.subtle.decrypt({ name: 'AES-GCM', iv: new Uint8Array(iv) }, key, ciphertext);
        return new TextDecoder().decode(decrypted);
    }
    
    // --- FROM constants.ts ---
    const user0_c = { id: 'user-0', name: 'Ich', avatarUrl: 'https://picsum.photos/seed/me/100/100', publicKey: {"crv":"P-256","ext":true,"key_ops":["deriveKey"],"kty":"EC","x":"f63EyC6a345-C00e-TAt_K-aF0-c0yX_Dcew7-2v8Is","y":"d5X9gO6c1qj2a_gI_e8o5A-f8b8C8F8c8c8c8c8c8c8"}, privateKey: {"crv":"P-256","d":"8a8J-l-s8-Q9f8c8c8c8c8c8c8c8c8c8c8c8c8c8c8","ext":true,"key_ops":["deriveKey"],"kty":"EC","x":"f63EyC6a345-C00e-TAt_K-aF0-c0yX_Dcew7-2v8Is","y":"d5X9gO6c1qj2a_gI_e8o5A-f8b8C8F8c8c8c8c8c8c8"} };
    const user1_c = { id: 'user-1', name: 'Lena Müller', avatarUrl: 'https://picsum.photos/seed/lena/100/100', publicKey: {"crv":"P-256","ext":true,"key_ops":["deriveKey"],"kty":"EC","x":"_4Y-e_X-a_Z_e_V_e_X-a_Z_e_V_e_X-a_Z_e_V_e_X-a","y":"_4Y-e_X-a_Z_e_V_e_X-a_Z_e_V_e_X-a_Z_e_V_e_X-b"}, privateKey: {"crv":"P-256","d":"_8c_e_X-a_Z_e_V_e_X-a_Z_e_V_e_X-a_Z_e_V_e_X-c","ext":true,"key_ops":["deriveKey"],"kty":"EC","x":"_4Y-e_X-a_Z_e_V_e_X-a_Z_e_V_e_X-a_Z_e_V_e_X-a","y":"_4Y-e_X-a_Z_e_V_e_X-a_Z_e_V_e_X-a_Z_e_V_e_X-b"} };
    const user2_c = { id: 'user-2', name: 'Max Schmidt', avatarUrl: 'https://picsum.photos/seed/max/100/100', publicKey: {"crv":"P-256","ext":true,"key_ops":["deriveKey"],"kty":"EC","x":"a_Z_e_V_e_X-a_Z_e_V_e_X-a_Z_e_V_e_X-a_Z_e_V_e","y":"b_Z_e_V_e_X-a_Z_e_V_e_X-a_Z_e_V_e_X-a_Z_e_V_f"}, privateKey: {"crv":"P-256","d":"c_Z_e_V_e_X-a_Z_e_V_e_X-a_Z_e_V_e_X-a_Z_e_V_g","ext":true,"key_ops":["deriveKey"],"kty":"EC","x":"a_Z_e_V_e_X-a_Z_e_V_e_X-a_Z_e_V_e_X-a_Z_e_V_e","y":"b_Z_e_V_e_X-a_Z_e_V_e_X-a_Z_e_V_e_X-a_Z_e_V_f"} };
    const user3_c = { id: 'user-3', name: 'Sophia Wagner', avatarUrl: 'https://picsum.photos/seed/sophia/100/100', publicKey: {"crv":"P-256","ext":true,"key_ops":["deriveKey"],"kty":"EC","x":"d_Z_e_V_e_X-a_Z_e_V_e_X-a_Z_e_V_e_X-a_Z_e_V_h","y":"e_Z_e_V_e_X-a_Z_e_V_e_X-a_Z_e_V_e_X-a_Z_e_V_i"}, privateKey: {"crv":"P-256","d":"f_Z_e_V_e_X-a_Z_e_V_e_X-a_Z_e_V_e_X-a_Z_e_V_j","ext":true,"key_ops":["deriveKey"],"kty":"EC","x":"d_Z_e_V_e_X-a_Z_e_V_e_X-a_Z_e_V_e_X-a_Z_e_V_h","y":"e_Z_e_V_e_X-a_Z_e_V_e_X-a_Z_e_V_e_X-a_Z_e_V_i"} };
    const ALL_USERS = [user0_c, user1_c, user2_c, user3_c];
    const INITIAL_USER = user0_c;

    // --- FROM services/geminiService.ts ---
    const geminiService = (() => {
      let ai_instance;
      function getAiInstance() {
          if (ai_instance) return ai_instance;
          try {
              if (process && process.env && process.env.API_KEY) {
                  ai_instance = new GoogleGenAI({ apiKey: process.env.API_KEY });
                  return ai_instance;
              }
          } catch (e) {
              // process is not defined
          }
          console.warn("API_KEY not found. Gemini AI features will be disabled. This is expected if not in an environment like AI Studio.");
          return null;
      }

      return {
          async getSmartReplies(conversationHistory) {
              const ai = getAiInstance();
              if (!ai) return [];
              try {
                  const lastMessage = conversationHistory.length > 0 ? conversationHistory[conversationHistory.length - 1].text : '';
                  const prompt = `Basierend auf der letzten Nachricht "${lastMessage}", generiere 3 kurze, prägnante Antwortvorschläge auf Deutsch. Gib nur ein JSON-Array von Strings zurück, sonst nichts. Beispiel: ["Ja, gerne!", "Vielleicht später.", "Ich bin mir nicht sicher."]\n`;
                  const response = await ai.models.generateContent({ model: 'gemini-flash-lite-latest', contents: prompt });
                  const jsonString = response.text.trim().replace(/\\\`\\\`\\\`json|\\\`\\\`\\\`/g, '');
                  const replies = JSON.parse(jsonString);
                  return Array.isArray(replies) ? replies.slice(0, 3) : [];
              } catch (error) {
                  console.error("Error getting smart replies:", error);
                  return [];
              }
          },
          async rewriteMessage(message, tone) {
              const ai = getAiInstance();
              if (!ai) return "AI-Funktion ist nicht verfügbar.";
              try {
                  const prompt = `Schreibe die folgende Nachricht ${tone} um. Gib nur den umgeschriebenen Text zurück, ohne zusätzliche Erklärung oder Anführungszeichen:\n\n"${message}"`;
                  const response = await ai.models.generateContent({ model: 'gemini-2.5-pro', contents: prompt });
                  return response.text.trim();
              } catch (error) {
                  console.error("Error rewriting message:", error);
                  return "Fehler beim Umschreiben der Nachricht.";
              }
          }
      };
    })();

    // --- FROM services/socketService.ts ---
    const socketService = new (class SocketService {
      ws = null;
      onMessageCallback = null;
      onInitialMessagesCallback = null;

      connect(userId, serverUrl, onMessage, onInitialMessages) {
        return new Promise((resolve, reject) => {
            if (this.ws) this.disconnect();
            this.onMessageCallback = onMessage;
            this.onInitialMessagesCallback = onInitialMessages;
            if (!serverUrl || !serverUrl.startsWith('ws')) {
                reject(new Error("Invalid WebSocket URL. It should start with ws:// or wss://"));
                return;
            }
            this.ws = new WebSocket(`${serverUrl}?userId=${userId}`);
            this.ws.onopen = () => resolve();
            this.ws.onmessage = (event) => {
                const data = JSON.parse(event.data);
                if (data.type === 'newMessage' && this.onMessageCallback) this.onMessageCallback(data.payload);
                if (data.type === 'initialMessages' && this.onInitialMessagesCallback) this.onInitialMessagesCallback(data.payload);
            };
            this.ws.onclose = () => this.ws = null;
            this.ws.onerror = (error) => {
                reject(error);
                this.ws = null;
            };
        });
      }
      sendMessage(message, recipientId) {
        if (this.ws?.readyState === WebSocket.OPEN) {
          this.ws.send(JSON.stringify({ type: 'sendMessage', payload: { message, recipientId } }));
        }
      }
      disconnect() {
        this.ws?.close();
        this.ws = null;
      }
    })();
    
    // --- FROM components/icons.tsx ---
    const LockIcon = ({ className }) => (<svg xmlns="http://www.w3.org/2000/svg" className={className} viewBox="0 0 20 20" fill="currentColor"><path fillRule="evenodd" d="M10 1a4.5 4.5 0 00-4.5 4.5V9H5a2 2 0 00-2 2v6a2 2 0 002 2h10a2 2 0 002-2v-6a2 2 0 00-2-2h-.5V5.5A4.5 4.5 0 0010 1zm3 8V5.5a3 3 0 10-6 0V9h6z" clipRule="evenodd" /></svg>);
    const SendIcon = ({ className }) => (<svg xmlns="http://www.w3.org/2000/svg" className={className} viewBox="0 0 20 20" fill="currentColor"><path d="M10.894 2.553a1 1 0 00-1.788 0l-7 14a1 1 0 001.169 1.409l5-1.429A1 1 0 009 15.571V11a1 1 0 112 0v4.571a1 1 0 00.725.962l5 1.428a1 1 0 001.17-1.408l-7-14z" /></svg>);
    const SparklesIcon = ({ className }) => (<svg xmlns="http://www.w3.org/2000/svg" className={className} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}><path strokeLinecap="round" strokeLinejoin="round" d="M5 3v4M3 5h4M6 17v4m-2-2h4m5-16l2.286 6.857L21 12l-5.714 2.143L13 21l-2.286-6.857L5 12l5.714-2.143L13 3z" /></svg>);
    const CheckIcon = ({ className }) => (<svg xmlns="http://www.w3.org/2000/svg" className={className} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}><path strokeLinecap="round" strokeLinejoin="round" d="M5 13l4 4L19 7" /></svg>);
    const DoubleCheckIcon = ({ className }) => (<svg xmlns="http://www.w3.org/2000/svg" className={className} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}><path strokeLinecap="round" strokeLinejoin="round" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>);
    const ClockIcon = ({ className }) => (<svg xmlns="http://www.w3.org/2000/svg" className={className} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}><path strokeLinecap="round" strokeLinejoin="round" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>);
    const XCircleIcon = ({ className }) => (<svg xmlns="http://www.w3.org/2000/svg" className={className} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}><path strokeLinecap="round" strokeLinejoin="round" d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>);

    // --- FROM components/MessageBubble.tsx ---
    const MessageBubble = ({ message, currentUserId, sharedKey }) => {
      const [decryptedText, setDecryptedText] = useState('');
      const [isDecrypting, setIsDecrypting] = useState(true);

      useEffect(() => {
        const decrypt = async () => {
          if (sharedKey && message.text) {
            setIsDecrypting(true);
            try {
              const text = await decryptMessage(message.text, sharedKey);
              setDecryptedText(text);
            } catch (error) {
              setDecryptedText("Fehler beim Entschlüsseln...");
            } finally {
              setIsDecrypting(false);
            }
          } else if (!message.text) {
              setDecryptedText("");
              setIsDecrypting(false);
          }
        };
        decrypt();
      }, [message.text, sharedKey]);

      const MessageStatusIndicator = ({ status }) => {
          switch (status) {
              case MessageStatus.SENDING: return <ClockIcon className="h-4 w-4 text-slate-400" />;
              case MessageStatus.SENT: return <CheckIcon className="h-4 w-4 text-slate-400" />;
              case MessageStatus.DELIVERED: return <DoubleCheckIcon className="h-4 w-4 text-slate-400" />;
              case MessageStatus.READ: return <DoubleCheckIcon className="h-4 w-4 text-sky-400" />;
              case MessageStatus.ERROR: return <XCircleIcon className="h-4 w-4 text-red-500" />;
              default: return null;
          }
      };

      const isCurrentUser = message.senderId === currentUserId;
      const bubbleClasses = isCurrentUser ? 'bg-sky-600 text-white self-end rounded-br-none' : 'bg-slate-700 text-slate-200 self-start rounded-bl-none';
      const time = new Date(message.timestamp).toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' });

      return (
        <div className={`flex items-end gap-2 ${isCurrentUser ? 'justify-end' : 'justify-start'}`}>
          <div className={`max-w-xs md:max-w-md lg:max-w-lg px-4 py-3 rounded-2xl ${bubbleClasses}`}>
            {isDecrypting ? <p className="italic text-slate-400">Entschlüsseln...</p> : <p className="break-words">{decryptedText}</p>}
            <div className="flex items-center justify-end gap-1 mt-1">
              <span className="text-xs opacity-70">{time}</span>
              {isCurrentUser && <MessageStatusIndicator status={message.status} />}
            </div>
          </div>
        </div>
      );
    };
    
    // --- FROM components/MessageInput.tsx ---
    const MessageInput = ({ onSendMessage, conversationContext }) => {
      const [text, setText] = useState('');
      const [isAiMenuOpen, setIsAiMenuOpen] = useState(false);
      const [isLoadingAi, setIsLoadingAi] = useState(false);
      const [smartReplies, setSmartReplies] = useState([]);

      const handleSendMessage = (e) => {
        e?.preventDefault();
        if (text.trim()) {
          onSendMessage(text.trim());
          setText('');
          setSmartReplies([]);
        }
      };

      const handleAiAction = useCallback(async (action) => {
        setIsLoadingAi(true);
        setIsAiMenuOpen(false);
        try {
            switch(action) {
                case AIFeature.SMART_REPLY:
                    const decryptedContext = await Promise.all(
                        conversationContext.map(m => ({ ...m, text: `Sprecher ${m.senderId}: ${m.decryptedText}` })) // Assuming text is decrypted already
                    );
                    const replies = await geminiService.getSmartReplies(decryptedContext);
                    setSmartReplies(replies);
                    break;
                case AIFeature.REWRITE_FORMAL:
                    if(text) setText(await geminiService.rewriteMessage(text, 'formeller'));
                    break;
                case AIFeature.REWRITE_CASUAL:
                    if(text) setText(await geminiService.rewriteMessage(text, 'legerer'));
                    break;
            }
        } finally {
            setIsLoadingAi(false);
        }
      }, [conversationContext, text]);
      
      const AIFeatureButton = ({ onClick, children, disabled }) => (<button onClick={onClick} disabled={disabled} className="w-full text-left px-4 py-2 text-sm text-slate-200 hover:bg-slate-700 disabled:opacity-50 transition-colors">{children}</button>);

      return (
        <div className="bg-slate-800 p-4 border-t border-slate-700">
            {smartReplies.length > 0 && (
                 <div className="flex gap-2 mb-3">{smartReplies.map((reply, i) => (<button key={i} onClick={() => onSendMessage(reply)} className="px-3 py-1.5 bg-slate-700 hover:bg-slate-600 text-slate-200 text-sm rounded-full">{reply}</button>))}</div>
            )}
          <div className="relative flex items-center gap-2">
            <div className="relative">
              <button onClick={() => setIsAiMenuOpen(!isAiMenuOpen)} className="p-2 rounded-full hover:bg-slate-700 text-slate-400 hover:text-sky-400"><SparklesIcon className="h-6 w-6" /></button>
              {isAiMenuOpen && (
                <div className="absolute bottom-full mb-2 w-56 bg-slate-800 border border-slate-700 rounded-lg shadow-xl z-10 overflow-hidden">
                    <AIFeatureButton onClick={() => handleAiAction(AIFeature.SMART_REPLY)} disabled={isLoadingAi || conversationContext.length === 0}>{AIFeature.SMART_REPLY}</AIFeatureButton>
                    <AIFeatureButton onClick={() => handleAiAction(AIFeature.REWRITE_FORMAL)} disabled={isLoadingAi || !text}>{AIFeature.REWRITE_FORMAL}</AIFeatureButton>
                    <AIFeatureButton onClick={() => handleAiAction(AIFeature.REWRITE_CASUAL)} disabled={isLoadingAi || !text}>{AIFeature.REWRITE_CASUAL}</AIFeatureButton>
                </div>
              )}
            </div>
            <form onSubmit={handleSendMessage} className="flex-1">
                <input type="text" value={text} onChange={(e) => setText(e.target.value)} placeholder="Nachricht schreiben..." className="w-full bg-slate-700 text-slate-200 rounded-full py-2.5 px-5 focus:outline-none focus:ring-2 focus:ring-sky-500" disabled={isLoadingAi} />
            </form>
            <button onClick={handleSendMessage} className="bg-sky-600 text-white p-2.5 rounded-full hover:bg-sky-500 disabled:bg-slate-600 disabled:cursor-not-allowed" disabled={!text.trim() || isLoadingAi}><SendIcon className="h-5 w-5" /></button>
          </div>
        </div>
      );
    };

    // --- FROM components/ContactList.tsx ---
    const ContactList = ({ contacts, messages, selectedContactId, onSelectContact, currentUser, onDisconnect }) => {
      const ContactItem = ({ contact, lastMessage, isSelected, onSelect }) => {
          const selectedClasses = isSelected ? 'bg-slate-700' : 'hover:bg-slate-800';
          const lastMessageTime = lastMessage ? new Date(lastMessage.timestamp).toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' }) : '';
          return (
            <li onClick={onSelect} className={`flex items-center p-3 cursor-pointer transition-colors ${selectedClasses}`}>
              <img src={contact.avatarUrl} alt={contact.name} className="h-12 w-12 rounded-full mr-4" />
              <div className="flex-1 overflow-hidden">
                <div className="flex justify-between items-center"><h3 className="font-semibold text-slate-100">{contact.name}</h3><span className="text-xs text-slate-400">{lastMessageTime}</span></div>
                <p className="text-sm text-slate-400 truncate italic">{lastMessage ? '... ' : 'Keine Nachrichten'}</p>
              </div>
            </li>
          );
      };
      return (
        <aside className="w-full md:w-80 lg:w-96 bg-slate-900 border-r border-slate-800 flex flex-col h-full">
          <div className="p-4 border-b border-slate-800 flex items-center justify-between">
            <div className="flex items-center"><img src={currentUser.avatarUrl} alt={currentUser.name} className="h-10 w-10 rounded-full mr-3" /><span className="font-semibold text-white">{currentUser.name}</span></div>
            <button onClick={onDisconnect} className="px-3 py-1.5 text-xs bg-slate-700 hover:bg-slate-600 text-slate-300 rounded-md">Trennen</button>
          </div>
          <header className="p-4 border-b border-slate-800"><h2 className="text-xl font-bold text-white">Chats</h2></header>
          <ul className="overflow-y-auto custom-scrollbar flex-1">
            {contacts.map((contact) => {
               const chatKey = [currentUser.id, contact.id].sort().join('-');
               const contactMessages = messages[chatKey] || [];
               return <ContactItem key={contact.id} contact={contact} lastMessage={contactMessages[contactMessages.length - 1]} isSelected={selectedContactId === contact.id} onSelect={() => onSelectContact(contact.id)} />;
            })}
          </ul>
        </aside>
      );
    };

    // --- FROM components/ChatWindow.tsx ---
    const ChatWindow = ({ contact, messages, onSendMessage, currentUser, sharedKey }) => {
        const messagesEndRef = useRef(null);
        useEffect(() => { messagesEndRef.current?.scrollIntoView({ behavior: "smooth" }); }, [messages]);

        if (!contact) {
            return (
              <main className="flex-1 bg-slate-800/50 hidden md:flex flex-col">
                <div className="flex flex-col items-center justify-center h-full text-center text-slate-500">
                    <LockIcon className="h-16 w-16 mb-4" />
                    <h2 className="text-xl font-semibold text-slate-300">Willkommen</h2>
                    <p className="max-w-sm mt-2">Wähle einen Kontakt aus, um eine Unterhaltung zu beginnen.</p>
                </div>
              </main>
            );
        }
        
        return (
            <main className="flex-1 flex flex-col bg-slate-800/50 h-full">
                <header className="flex items-center p-4 bg-slate-900 border-b border-slate-800">
                    <img src={contact.avatarUrl} alt={contact.name} className="h-10 w-10 rounded-full mr-4" />
                    <div>
                        <h3 className="text-lg font-semibold text-white">{contact.name}</h3>
                        <div className="flex items-center text-xs text-green-400 mt-1"><LockIcon className="h-3 w-3 mr-1" /><span>End-to-End-verschlüsselt</span></div>
                    </div>
                </header>
                <div className="flex-1 p-6 overflow-y-auto custom-scrollbar">
                    <div className="flex flex-col gap-4">
                        {messages.map((msg) => <MessageBubble key={msg.id} message={msg} currentUserId={currentUser.id} sharedKey={sharedKey} />)}
                        <div ref={messagesEndRef} />
                    </div>
                </div>
                <MessageInput onSendMessage={onSendMessage} conversationContext={messages} />
            </main>
        );
    };
    
    // --- FROM components/ConnectionView.tsx ---
    const ConnectionView = ({ onConnect, allUsers }) => {
        const [selectedUser, setSelectedUser] = useState(INITIAL_USER);
        const [urlInput, setUrlInput] = useState('ws://localhost:8080');
        const [isLoading, setIsLoading] = useState(false);

        const handleSubmit = (e) => {
            e.preventDefault();
            setIsLoading(true);
            setTimeout(() => onConnect(selectedUser, urlInput), 250);
        }

        return (
            <div className="w-screen h-screen bg-slate-900 flex items-center justify-center p-4">
                <div className="w-full max-w-md bg-slate-800 text-slate-200 rounded-2xl shadow-xl p-8 border border-slate-700">
                    <div className="text-center mb-8"><h1 className="text-3xl font-bold text-white">Gemini Secure Messenger</h1><p className="text-slate-400 mt-2">Sicher verbinden</p></div>
                    <form onSubmit={handleSubmit} className="space-y-6">
                        <div>
                            <label htmlFor="user-select" className="block text-sm font-medium text-slate-300 mb-2">1. Wer sind Sie?</label>
                            <select id="user-select" value={selectedUser.id} onChange={(e) => setSelectedUser(allUsers.find(u => u.id === e.target.value))} className="w-full bg-slate-700 border border-slate-600 rounded-lg py-2.5 px-4 focus:outline-none focus:ring-2 focus:ring-sky-500">
                                {allUsers.map(user => <option key={user.id} value={user.id}>{user.name}</option>)}
                            </select>
                        </div>
                        <div>
                            <label htmlFor="server-url" className="block text-sm font-medium text-slate-300 mb-2">2. Geben Sie Ihre Server-URL ein</label>
                            <input id="server-url" type="text" value={urlInput} onChange={(e) => setUrlInput(e.target.value)} placeholder="z.B. wss://mein-server.onrender.com" className="w-full bg-slate-700 border border-slate-600 rounded-lg py-2.5 px-4 focus:outline-none focus:ring-2 focus:ring-sky-500" />
                            <p className="text-xs text-slate-500 mt-2">Dies ist die Adresse Ihres gehosteten Backends.</p>
                        </div>
                        <button type="submit" disabled={isLoading} className="w-full bg-sky-600 text-white font-semibold py-3 rounded-lg hover:bg-sky-500 transition-colors disabled:bg-slate-600 flex items-center justify-center">{isLoading ? 'Verbinde...' : 'Verbinden und Chat starten'}</button>
                    </form>
                </div>
            </div>
        );
    }
    
    // --- FROM App.tsx ---
    function App() {
      const [session, setSession] = useState(null);
      const [messages, setMessages] = useState({});
      const [sharedKeys, setSharedKeys] = useState({});
      const firstContact = ALL_USERS.find(u => u.id !== INITIAL_USER.id);
      const [selectedContactId, setSelectedContactId] = useState(firstContact?.id || null);
      
      const getChatKey = (id1, id2) => [id1, id2].sort().join('-');

      useEffect(() => {
        if (!session) { socketService.disconnect(); return; }
        
        const handleNewMessage = (message) => {
          const otherUserId = message.senderId === session.user.id ? message.chatKey.replace(session.user.id, '').replace('-', '') : message.senderId;
          const chatKey = getChatKey(session.user.id, otherUserId);
          setMessages(prev => ({ ...prev, [chatKey]: [...(prev[chatKey] || []), message] }));
        };
        const handleInitialMessages = (initialMessages) => setMessages(initialMessages);
        
        socketService.connect(session.user.id, session.serverUrl, handleNewMessage, handleInitialMessages)
          .catch(err => {
            alert(`Verbindung zum Server fehlgeschlagen: ${err.message || 'URL prüfen.'}`);
            handleDisconnect();
          });
          
        return () => socketService.disconnect();
      }, [session]);

      useEffect(() => {
        if (!session) return;
        const establishKeys = async () => {
          const newKeys = {};
          for (const user of ALL_USERS) {
            if (user.id !== session.user.id) {
              const key = await deriveSharedKey(session.user.privateKey, user.publicKey);
              newKeys[getChatKey(session.user.id, user.id)] = key;
            }
          }
          setSharedKeys(newKeys);
        };
        establishKeys();
      }, [session]);

      const handleDisconnect = () => {
        setSession(null);
        setMessages({});
        setSharedKeys({});
        setSelectedContactId(firstContact?.id || null);
      };

      const handleSendMessage = async (text) => {
        if (!selectedContactId || !session) return;
        const chatKey = getChatKey(session.user.id, selectedContactId);
        const sharedKey = sharedKeys[chatKey];
        if (!sharedKey) return;

        const encryptedText = await encryptMessage(text, sharedKey);
        const newMessage = { id: `msg-${Date.now()}`, senderId: session.user.id, text: encryptedText, timestamp: Date.now(), status: MessageStatus.SENT, chatKey };
        
        socketService.sendMessage(newMessage, selectedContactId);
        setMessages(prev => ({ ...prev, [chatKey]: [...(prev[chatKey] || []), newMessage] }));
      };
      
      if (!session) {
        return <ConnectionView onConnect={(user, url) => setSession({ user, serverUrl: url })} allUsers={ALL_USERS} />;
      }
      
      const { user: currentUser } = session;
      const displayedContacts = ALL_USERS.filter(c => c.id !== currentUser.id);
      const selectedContact = ALL_USERS.find(c => c.id === selectedContactId);
      const chatKey = selectedContactId ? getChatKey(currentUser.id, selectedContactId) : null;
      const selectedContactMessages = chatKey ? messages[chatKey] || [] : [];
      
      return (
        <div className="bg-slate-900 text-slate-300 h-screen w-screen flex antialiased">
          <div className={`w-full md:w-auto md:flex flex-col h-full ${selectedContactId ? 'hidden md:flex' : 'flex'}`}>
            <ContactList contacts={displayedContacts} messages={messages} selectedContactId={selectedContactId} onSelectContact={setSelectedContactId} currentUser={currentUser} onDisconnect={handleDisconnect} />
          </div>
           <div className={`w-full h-full ${selectedContactId ? 'flex' : 'hidden md:flex'}`}>
            <ChatWindow contact={selectedContact} messages={selectedContactMessages} onSendMessage={handleSendMessage} currentUser={currentUser} sharedKey={chatKey ? sharedKeys[chatKey] : null} />
          </div>
        </div>
      );
    }
    
    // --- FROM index.tsx ---
    const rootElement = document.getElementById('root');
    const root = ReactDOM.createRoot(rootElement);
    root.render(<React.StrictMode><App /></React.StrictMode>);
  </script>
</body>
</html>
