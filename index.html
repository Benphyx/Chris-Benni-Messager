<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-T-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Gemini Secure Messenger</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    body { font-family: 'Inter', sans-serif; }
    .custom-scrollbar::-webkit-scrollbar { width: 6px; }
    .custom-scrollbar::-webkit-scrollbar-track { background: #1e293b; }
    .custom-scrollbar::-webkit-scrollbar-thumb { background: #475569; border-radius: 3px; }
    .custom-scrollbar::-webkit-scrollbar-thumb:hover { background: #64748b; }
  </style>
<!-- Load React and ReactDOM as global variables -->
<script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
<script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
<!-- Load GoogleGenAI and attach it to the window object -->
<script type="module">
  import { GoogleGenAI } from "https://aistudiocdn.com/@google/genai@^1.27.0";
  window.GoogleGenAI = GoogleGenAI;
</script>
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel" data-presets="react,typescript">
    // --- CONSOLIDATED APPLICATION CODE ---
    // All .ts and .tsx files have been inlined here to create a single, deployable file.
    
    // --- FROM types.ts ---
    const MessageStatus = {
      SENT: 'sent',
      DELIVERED: 'delivered',
      READ: 'read',
      SENDING: 'sending',
      ERROR: 'error',
    };
    const AIFeature = {
      SMART_REPLY: 'Smarte Antworten',
    };

    // --- FROM services/cryptoService.ts ---
    function arrayBufferToBase64(buffer) {
        let binary = '';
        const bytes = new Uint8Array(buffer);
        for (let i = 0; i < bytes.byteLength; i++) {
            binary += String.fromCharCode(bytes[i]);
        }
        return window.btoa(binary);
    }
    function base64ToArrayBuffer(base64) {
        const binary_string = window.atob(base64);
        const len = binary_string.length;
        const bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            bytes[i] = binary_string.charCodeAt(i);
        }
        return bytes.buffer;
    }
    async function importPrivateKey(jwk) {
        return await crypto.subtle.importKey('jwk', jwk, { name: 'ECDH', namedCurve: 'P-256' }, true, ['deriveKey']);
    }
    async function importPublicKey(jwk) {
        return await crypto.subtle.importKey('jwk', jwk, { name: 'ECDH', namedCurve: 'P-256' }, true, []);
    }
    async function deriveSharedKey(privateKeyJwk, publicKeyJwk) {
        const privateKey = await importPrivateKey(privateKeyJwk);
        const publicKey = await importPublicKey(publicKeyJwk);
        return await crypto.subtle.deriveKey({ name: 'ECDH', public: publicKey }, privateKey, { name: 'AES-GCM', length: 256 }, true, ['encrypt', 'decrypt']);
    }
    async function encryptMessage(text, key) {
        const encodedText = new TextEncoder().encode(text);
        const iv = crypto.getRandomValues(new Uint8Array(12));
        const ciphertext = await crypto.subtle.encrypt({ name: 'AES-GCM', iv }, key, encodedText);
        const combined = new Uint8Array(iv.length + ciphertext.byteLength);
        combined.set(iv, 0);
        combined.set(new Uint8Array(ciphertext), iv.length);
        return arrayBufferToBase64(combined.buffer);
    }
    async function decryptMessage(encryptedBase64, key) {
        const combined = base64ToArrayBuffer(encryptedBase64);
        const iv = combined.slice(0, 12);
        const ciphertext = combined.slice(12);
        const decrypted = await crypto.subtle.decrypt({ name: 'AES-GCM', iv: new Uint8Array(iv) }, key, ciphertext);
        return new TextDecoder().decode(decrypted);
    }
    
    // --- FROM constants.ts ---
    // NOTE: Using placeholder keys. In a real app, these would be generated and stored securely.
    const chris_c = { id: 'user-chris', name: 'Chris', avatarUrl: 'https://i.pravatar.cc/100?u=chris', privateKey: {"kty":"EC","crv":"P-256","x":"_CH-e_X-a_Z_e_V_e_X-a_Z_e_V_e_X-a_Z_e_V_e_X-a","y":"_CH-e_X-a_Z_e_V_e_X-a_Z_e_V_e_X-a_Z_e_V_e_X-b","d":"_CH_e_X-a_Z_e_V_e_X-a_Z_e_V_e_X-a_Z_e_V_e_X-c"}, publicKey: {"kty":"EC","crv":"P-256","x":"_CH-e_X-a_Z_e_V_e_X-a_Z_e_V_e_X-a_Z_e_V_e_X-a","y":"_CH-e_X-a_Z_e_V_e_X-a_Z_e_V_e_X-a_Z_e_V_e_X-b"} };
    const benni_c = { id: 'user-benni', name: 'Benni', avatarUrl: 'https://i.pravatar.cc/100?u=benni', privateKey: {"kty":"EC","crv":"P-256","x":"a_BE_e_V_e_X-a_Z_e_V_e_X-a_Z_e_V_e_X-a_Z_e_V_e","y":"b_BE_e_V_e_X-a_Z_e_V_e_X-a_Z_e_V_e_X-a_Z_e_V_f","d":"c_BE_e_V_e_X-a_Z_e_V_e_X-a_Z_e_V_e_X-a_Z_e_V_g"}, publicKey: {"kty":"EC","crv":"P-256","x":"a_BE_e_V_e_X-a_Z_e_V_e_X-a_Z_e_V_e_X-a_Z_e_V_e","y":"b_BE_e_V_e_X-a_Z_e_V_e_X-a_Z_e_V_e_X-a_Z_e_V_f"} };
    const ALL_USERS = [chris_c, benni_c];
    const INITIAL_USER = chris_c;

    // --- FROM services/geminiService.ts ---
    const geminiService = (() => {
      let ai_instance;
      function getAiInstance() {
          if (ai_instance) return ai_instance;
          try {
              if (window.GoogleGenAI && window.process && window.process.env && window.process.env.API_KEY) {
                  ai_instance = new window.GoogleGenAI({ apiKey: window.process.env.API_KEY });
                  return ai_instance;
              }
          } catch (e) { /* process is not defined in browser */ }
           if (window.GoogleGenAI) {
              console.warn("API_KEY not found. Gemini AI features will be disabled. This is expected if not in an environment like AI Studio.");
              return null;
          }
          console.warn("GoogleGenAI library not loaded. AI features disabled.");
          return null;
      }

      return {
          async getSmartReplies(conversationHistory) {
              const ai = getAiInstance();
              if (!ai) return [];
              try {
                  const lastMessage = conversationHistory.length > 0 ? conversationHistory[conversationHistory.length - 1].text : '';
                  const prompt = `Basierend auf der letzten Nachricht "${lastMessage}", generiere 3 kurze, prägnante Antwortvorschläge auf Deutsch. Gib nur ein JSON-Array von Strings zurück, sonst nichts. Beispiel: ["Ja, gerne!", "Vielleicht später.", "Ich bin mir nicht sicher."]\n`;
                  const response = await ai.models.generateContent({ model: 'gemini-flash-lite-latest', contents: prompt });
                  const jsonString = response.text.trim().replace(/^```json\n?|```$/g, '');
                  const replies = JSON.parse(jsonString);
                  return Array.isArray(replies) ? replies.slice(0, 3) : [];
              } catch (error) {
                  console.error("Error getting smart replies:", error);
                  return [];
              }
          }
      };
    })();

    // --- FROM services/socketService.ts ---
    const socketService = new (class SocketService {
      ws = null;
      onMessageCallback = null;
      onInitialMessagesCallback = null;

      connect(userId, serverUrl, onMessage, onInitialMessages) {
        return new Promise((resolve, reject) => {
            if (this.ws) this.disconnect();
            this.onMessageCallback = onMessage;
            this.onInitialMessagesCallback = onInitialMessages;
            if (!serverUrl || !serverUrl.startsWith('ws')) {
                reject(new Error("Invalid WebSocket URL. It should start with ws:// or wss://"));
                return;
            }
            this.ws = new WebSocket(`${serverUrl}?userId=${userId}`);
            this.ws.onopen = () => resolve();
            this.ws.onmessage = (event) => {
                const data = JSON.parse(event.data);
                if (data.type === 'newMessage' && this.onMessageCallback) this.onMessageCallback(data.payload);
                if (data.type === 'initialMessages' && this.onInitialMessagesCallback) this.onInitialMessagesCallback(data.payload);
            };
            this.ws.onclose = () => this.ws = null;
            this.ws.onerror = (error) => {
                reject(error);
                this.ws = null;
            };
        });
      }
      sendMessage(message, recipientId) {
        if (this.ws?.readyState === WebSocket.OPEN) {
          this.ws.send(JSON.stringify({ type: 'sendMessage', payload: { message, recipientId } }));
        }
      }
      disconnect() {
        this.ws?.close();
        this.ws = null;
      }
    })();
    
    // --- FROM components/icons.tsx ---
    const LockIcon = ({ className }) => (<svg xmlns="http://www.w3.org/2000/svg" className={className} viewBox="0 0 20 20" fill="currentColor"><path fillRule="evenodd" d="M10 1a4.5 4.5 0 00-4.5 4.5V9H5a2 2 0 00-2 2v6a2 2 0 002 2h10a2 2 0 002-2v-6a2 2 0 00-2-2h-.5V5.5A4.5 4.5 0 0010 1zm3 8V5.5a3 3 0 10-6 0V9h6z" clipRule="evenodd" /></svg>);
    const SendIcon = ({ className }) => (<svg xmlns="http://www.w3.org/2000/svg" className={className} viewBox="0 0 20 20" fill="currentColor"><path d="M10.894 2.553a1 1 0 00-1.788 0l-7 14a1 1 0 001.169 1.409l5-1.429A1 1 0 009 15.571V11a1 1 0 112 0v4.571a1 1 0 00.725.962l5 1.428a1 1 0 001.17-1.408l-7-14z" /></svg>);
    const SparklesIcon = ({ className }) => (<svg xmlns="http://www.w3.org/2000/svg" className={className} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}><path strokeLinecap="round" strokeLinejoin="round" d="M5 3v4M3 5h4M6 17v4m-2-2h4m5-16l2.286 6.857L21 12l-5.714 2.143L13 21l-2.286-6.857L5 12l5.714-2.143L13 3z" /></svg>);
    const CheckIcon = ({ className }) => (<svg xmlns="http://www.w3.org/2000/svg" className={className} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}><path strokeLinecap="round" strokeLinejoin="round" d="M5 13l4 4L19 7" /></svg>);
    const DoubleCheckIcon = ({ className }) => (<svg xmlns="http://www.w3.org/2000/svg" className={className} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}><path strokeLinecap="round" strokeLinejoin="round" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>);
    const ClockIcon = ({ className }) => (<svg xmlns="http://www.w3.org/2000/svg" className={className} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}><path strokeLinecap="round" strokeLinejoin="round" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>);
    const XCircleIcon = ({ className }) => (<svg xmlns="http://www.w3.org/2000/svg" className={className} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}><path strokeLinecap="round" strokeLinejoin="round" d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>);

    // --- FROM components/MessageBubble.tsx ---
    const MessageBubble = ({ message, currentUserId, sharedKey }) => {
      const [decryptedText, setDecryptedText] = React.useState('');
      const [isDecrypting, setIsDecrypting] = React.useState(true);

      React.useEffect(() => {
        const decrypt = async () => {
          if (sharedKey && message.text) {
            setIsDecrypting(true);
            try {
              const text = await decryptMessage(message.text, sharedKey);
              setDecryptedText(text);
            } catch (error) {
              console.error("Decryption failed:", error);
              setDecryptedText("🔒 Fehler beim Entschlüsseln");
            } finally {
              setIsDecrypting(false);
            }
          } else if (!message.text) {
              setDecryptedText("");
              setIsDecrypting(false);
          } else {
              setDecryptedText("🔒 Schlüssel fehlt");
              setIsDecrypting(false);
          }
        };
        decrypt();
      }, [message.text, sharedKey]);

      const MessageStatusIndicator = ({ status }) => {
          switch (status) {
              case MessageStatus.SENDING: return <ClockIcon className="h-4 w-4 text-slate-400" />;
              case MessageStatus.SENT: return <CheckIcon className="h-4 w-4 text-slate-400" />;
              case MessageStatus.DELIVERED: return <DoubleCheckIcon className="h-4 w-4 text-slate-400" />;
              case MessageStatus.READ: return <DoubleCheckIcon className="h-4 w-4 text-sky-400" />;
              case MessageStatus.ERROR: return <XCircleIcon className="h-4 w-4 text-red-500" />;
              default: return null;
          }
      };

      const isCurrentUser = message.senderId === currentUserId;
      const bubbleClasses = isCurrentUser ? 'bg-sky-600 text-white self-end rounded-br-none' : 'bg-slate-700 text-slate-200 self-start rounded-bl-none';
      const time = new Date(message.timestamp).toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' });

      return (
        <div className={`flex items-end gap-2 ${isCurrentUser ? 'justify-end' : 'justify-start'}`}>
          <div className={`max-w-xs md:max-w-md lg:max-w-lg px-4 py-3 rounded-2xl ${bubbleClasses}`}>
            {isDecrypting ? <p className="italic text-slate-400">Entschlüsseln...</p> : <p className="break-words">{decryptedText}</p>}
            <div className="flex items-center justify-end gap-1 mt-1">
              <span className="text-xs opacity-70">{time}</span>
              {isCurrentUser && <MessageStatusIndicator status={message.status} />}
            </div>
          </div>
        </div>
      );
    };
    
    // --- FROM components/MessageInput.tsx ---
    const MessageInput = ({ onSendMessage, conversationContext }) => {
      const [text, setText] = React.useState('');
      const [isAiMenuOpen, setIsAiMenuOpen] = React.useState(false);
      const [isLoadingAi, setIsLoadingAi] = React.useState(false);
      const [smartReplies, setSmartReplies] = React.useState([]);

      const handleSendMessage = (e) => {
        e?.preventDefault();
        if (text.trim()) {
          onSendMessage(text.trim());
          setText('');
          setSmartReplies([]);
        }
      };

      const handleAiAction = React.useCallback(async (action) => {
        setIsLoadingAi(true);
        setIsAiMenuOpen(false);
        try {
            switch(action) {
                case AIFeature.SMART_REPLY:
                    const decryptedContext = conversationContext.map(m => `Sprecher ${m.senderId}: ${m.decryptedText || ''}`);
                    const replies = await geminiService.getSmartReplies(decryptedContext);
                    setSmartReplies(replies);
                    break;
            }
        } finally {
            setIsLoadingAi(false);
        }
      }, [conversationContext, text]);
      
      const AIFeatureButton = ({ onClick, children, disabled }) => (<button onClick={onClick} disabled={disabled} className="w-full text-left px-4 py-2 text-sm text-slate-200 hover:bg-slate-700 disabled:opacity-50 transition-colors">{children}</button>);

      return (
        <div className="bg-slate-800 p-4 border-t border-slate-700">
            {smartReplies.length > 0 && (
                 <div className="flex gap-2 mb-3">{smartReplies.map((reply, i) => (<button key={i} onClick={() => onSendMessage(reply)} className="px-3 py-1.5 bg-slate-700 hover:bg-slate-600 text-slate-200 text-sm rounded-full">{reply}</button>))}</div>
            )}
          <div className="relative flex items-center gap-2">
            <div className="relative">
              <button onClick={() => setIsAiMenuOpen(!isAiMenuOpen)} className="p-2 rounded-full hover:bg-slate-700 text-slate-400 hover:text-sky-400"><SparklesIcon className="h-6 w-6" /></button>
              {isAiMenuOpen && (
                <div className="absolute bottom-full mb-2 w-56 bg-slate-800 border border-slate-700 rounded-lg shadow-xl z-10 overflow-hidden">
                    <AIFeatureButton onClick={() => handleAiAction(AIFeature.SMART_REPLY)} disabled={isLoadingAi || conversationContext.length === 0}>{AIFeature.SMART_REPLY}</AIFeatureButton>
                </div>
              )}
            </div>
            <form onSubmit={handleSendMessage} className="flex-1">
                <input type="text" value={text} onChange={(e) => setText(e.target.value)} placeholder="Nachricht schreiben..." className="w-full bg-slate-700 text-slate-200 rounded-full py-2.5 px-5 focus:outline-none focus:ring-2 focus:ring-sky-500" disabled={isLoadingAi} />
            </form>
            <button onClick={handleSendMessage} className="bg-sky-600 text-white p-2.5 rounded-full hover:bg-sky-500 disabled:bg-slate-600 disabled:cursor-not-allowed" disabled={!text.trim() || isLoadingAi}><SendIcon className="h-5 w-5" /></button>
          </div>
        </div>
      );
    };

    // --- FROM components/ContactList.tsx ---
    const ContactList = ({ contacts, messages, selectedContactId, onSelectContact, currentUser, onDisconnect }) => {
      const ContactItem = ({ contact, lastMessage, isSelected, onSelect }) => {
          const selectedClasses = isSelected ? 'bg-slate-700' : 'hover:bg-slate-800';
          const lastMessageTime = lastMessage ? new Date(lastMessage.timestamp).toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' }) : '';
          return (
            <li onClick={onSelect} className={`flex items-center p-3 cursor-pointer transition-colors ${selectedClasses}`}>
              <img src={contact.avatarUrl} alt={contact.name} className="h-12 w-12 rounded-full mr-4" />
              <div className="flex-1 overflow-hidden">
                <div className="flex justify-between items-center"><h3 className="font-semibold text-slate-100">{contact.name}</h3><span className="text-xs text-slate-400">{lastMessageTime}</span></div>
                <p className="text-sm text-slate-400 truncate italic">{lastMessage ? 'Verschlüsselte Nachricht...' : 'Keine Nachrichten'}</p>
              </div>
            </li>
          );
      };
      return (
        <aside className="w-full md:w-80 lg:w-96 bg-slate-900 border-r border-slate-800 flex flex-col h-full">
          <div className="p-4 border-b border-slate-800 flex items-center justify-between">
            <div className="flex items-center"><img src={currentUser.avatarUrl} alt={currentUser.name} className="h-10 w-10 rounded-full mr-3" /><span className="font-semibold text-white">{currentUser.name}</span></div>
            <button onClick={onDisconnect} className="px-3 py-1.5 text-xs bg-slate-700 hover:bg-slate-600 text-slate-300 rounded-md">Trennen</button>
          </div>
          <header className="p-4 border-b border-slate-800"><h2 className="text-xl font-bold text-white">Chats</h2></header>
          <ul className="overflow-y-auto custom-scrollbar flex-1">
            {contacts.map((contact) => {
               const chatKey = [currentUser.id, contact.id].sort().join('-');
               const contactMessages = messages[chatKey] || [];
               return <ContactItem key={contact.id} contact={contact} lastMessage={contactMessages[contactMessages.length - 1]} isSelected={selectedContactId === contact.id} onSelect={() => onSelectContact(contact.id)} />;
            })}
          </ul>
        </aside>
      );
    };

    // --- FROM components/ChatWindow.tsx ---
    const ChatWindow = ({ contact, messages, onSendMessage, currentUser, sharedKey }) => {
        const messagesEndRef = React.useRef(null);
        React.useEffect(() => { messagesEndRef.current?.scrollIntoView({ behavior: "smooth" }); }, [messages]);

        if (!contact) {
            return (
              <main className="flex-1 bg-slate-800/50 hidden md:flex flex-col">
                <div className="flex flex-col items-center justify-center h-full text-center text-slate-500">
                    <LockIcon className="h-16 w-16 mb-4" />
                    <h2 className="text-xl font-semibold text-slate-300">Willkommen</h2>
                    <p className="max-w-sm mt-2">Wähle einen Kontakt aus, um eine Unterhaltung zu beginnen.</p>
                </div>
              </main>
            );
        }
        
        return (
            <main className="flex-1 flex flex-col bg-slate-800/50 h-full">
                <header className="flex items-center p-4 bg-slate-900 border-b border-slate-800">
                    <img src={contact.avatarUrl} alt={contact.name} className="h-10 w-10 rounded-full mr-4" />
                    <div>
                        <h3 className="text-lg font-semibold text-white">{contact.name}</h3>
                        <div className="flex items-center text-xs text-green-400 mt-1"><LockIcon className="h-3 w-3 mr-1" /><span>End-to-End-verschlüsselt</span></div>
                    </div>
                </header>
                <div className="flex-1 p-6 overflow-y-auto custom-scrollbar">
                    <div className="flex flex-col gap-4">
                        {messages.map((msg) => <MessageBubble key={msg.id} message={msg} currentUserId={currentUser.id} sharedKey={sharedKey} />)}
                        <div ref={messagesEndRef} />
                    </div>
                </div>
                <MessageInput onSendMessage={onSendMessage} conversationContext={messages} />
            </main>
        );
    };
    
    // --- FROM components/ConnectionView.tsx ---
    const ConnectionView = ({ onConnect, allUsers }) => {
        const [selectedUser, setSelectedUser] = React.useState(INITIAL_USER);
        const [urlInput, setUrlInput] = React.useState('wss://');
        const [isLoading, setIsLoading] = React.useState(false);
        const [error, setError] = React.useState('');

        const handleSubmit = async (e) => {
            e.preventDefault();
            setIsLoading(true);
            setError('');
            try {
                await onConnect(selectedUser, urlInput);
            } catch (err) {
                setError('Verbindung fehlgeschlagen. Überprüfen Sie die URL und versuchen Sie es erneut.');
                setIsLoading(false);
            }
        }

        return (
            <div className="w-screen h-screen bg-slate-900 flex items-center justify-center p-4">
                <div className="w-full max-w-md bg-slate-800 text-slate-200 rounded-2xl shadow-xl p-8 border border-slate-700">
                    <div className="text-center mb-8"><h1 className="text-3xl font-bold text-white">Gemini Secure Messenger</h1><p className="text-slate-400 mt-2">Sicher verbinden</p></div>
                    <form onSubmit={handleSubmit} className="space-y-6">
                        <div>
                            <label htmlFor="user-select" className="block text-sm font-medium text-slate-300 mb-2">1. Wer sind Sie?</label>
                            <select id="user-select" value={selectedUser.id} onChange={(e) => setSelectedUser(allUsers.find(u => u.id === e.target.value))} className="w-full bg-slate-700 border border-slate-600 rounded-lg py-2.5 px-4 focus:outline-none focus:ring-2 focus:ring-sky-500">
                                {allUsers.map(user => <option key={user.id} value={user.id}>{user.name}</option>)}
                            </select>
                        </div>
                        <div>
                            <label htmlFor="server-url" className="block text-sm font-medium text-slate-300 mb-2">2. Geben Sie Ihre Server-URL ein</label>
                            <input 
                                id="server-url" 
                                type="text" 
                                value={urlInput} 
                                onChange={(e) => setUrlInput(e.target.value)} 
                                placeholder="wss://your-server.onrender.com" 
                                className="w-full bg-slate-700 border border-slate-600 rounded-lg py-2.5 px-4 focus:outline-none focus:ring-2 focus:ring-sky-500" 
                                required 
                            />
                        </div>
                        {error && <p className="text-sm text-red-400 text-center">{error}</p>}
                        <div>
                            <button 
                                type="submit" 
                                className="w-full bg-sky-600 text-white font-semibold rounded-lg py-3 hover:bg-sky-500 transition-colors disabled:bg-slate-600 disabled:cursor-wait" 
                                disabled={isLoading}
                            >
                                {isLoading ? 'Verbinde...' : 'Verbinden und Chat starten'}
                            </button>
                        </div>
                    </form>
                </div>
            </div>
        );
    };

    // --- FROM App.tsx ---
    const App = () => {
        const [session, setSession] = React.useState({ currentUser: null, serverUrl: null });
        const [selectedContactId, setSelectedContactId] = React.useState(null);
        const [messages, setMessages] = React.useState({});
        const [sharedKeys, setSharedKeys] = React.useState({});

        const handleConnect = async (user, url) => {
            await socketService.connect(
                user.id,
                url,
                (newMessage) => { // onMessage
                    setMessages(prev => ({
                        ...prev,
                        [newMessage.chatKey]: [...(prev[newMessage.chatKey] || []), newMessage]
                    }));
                },
                (initialMessages) => { // onInitialMessages
                    setMessages(initialMessages);
                }
            );
            setSession({ currentUser: user, serverUrl: url });
        };
        
        const handleDisconnect = () => {
            socketService.disconnect();
            setSession({ currentUser: null, serverUrl: null });
            setSelectedContactId(null);
            setMessages({});
            setSharedKeys({});
        };

        const handleSelectContact = async (contactId) => {
            setSelectedContactId(contactId);
            const contact = ALL_USERS.find(u => u.id === contactId);
            if (!contact || !session.currentUser) return;
            const keyId = [session.currentUser.id, contact.id].sort().join('-');
            if (!sharedKeys[keyId]) {
                const key = await deriveSharedKey(session.currentUser.privateKey, contact.publicKey);
                setSharedKeys(prev => ({ ...prev, [keyId]: key }));
            }
        };

        const handleSendMessage = async (text) => {
            const { currentUser } = session;
            if (!currentUser || !selectedContactId) return;

            const contact = ALL_USERS.find(u => u.id === selectedContactId);
            const chatKey = [currentUser.id, contact.id].sort().join('-');
            const sharedKey = sharedKeys[chatKey];

            if (!sharedKey) {
                console.error("Shared key not available for this contact.");
                return;
            }
            
            const encryptedText = await encryptMessage(text, sharedKey);
            
            const newMessage = {
                id: crypto.randomUUID(),
                chatKey: chatKey,
                senderId: currentUser.id,
                recipientId: selectedContactId,
                text: encryptedText,
                timestamp: Date.now(),
                status: MessageStatus.SENT,
            };

            setMessages(prev => ({
                ...prev,
                [chatKey]: [...(prev[chatKey] || []), newMessage]
            }));

            socketService.sendMessage(newMessage, selectedContactId);
        };
        
        if (!session.currentUser) {
            return <ConnectionView onConnect={handleConnect} allUsers={ALL_USERS} />;
        }
        
        const { currentUser } = session;
        const contacts = ALL_USERS.filter(u => u.id !== currentUser.id);
        const selectedContact = contacts.find(c => c.id === selectedContactId);
        const chatKey = selectedContact ? [currentUser.id, selectedContact.id].sort().join('-') : null;
        const currentMessages = chatKey ? messages[chatKey] || [] : [];
        
        return (
            <div className="h-screen w-screen bg-slate-800 text-slate-200 flex overflow-hidden">
                <ContactList
                    contacts={contacts}
                    messages={messages}
                    selectedContactId={selectedContactId}
                    onSelectContact={handleSelectContact}
                    currentUser={currentUser}
                    onDisconnect={handleDisconnect}
                />
                <ChatWindow
                    contact={selectedContact}
                    messages={currentMessages}
                    onSendMessage={handleSendMessage}
                    currentUser={currentUser}
                    sharedKey={chatKey ? sharedKeys[chatKey] : null}
                />
            </div>
        );
    };

    // --- RENDER THE APP ---
    const container = document.getElementById('root');
    const root = ReactDOM.createRoot(container);
    root.render(<App />);
  </script>
</body>
</html>